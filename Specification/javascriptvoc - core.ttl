prefix dcm:       <http://purl.org/dc/dcmitype/>
prefix dct:       <http://purl.org/dc/terms/>
prefix decl:      <https://www.javascript.fin.rijksweb.nl/model/decl/>
prefix foaf:      <http://xmlns.com/foaf/0.1/>
prefix js:        <https://www.javascript.fin.rijksweb.nl/model/def/>
prefix owl:       <http://www.w3.org/2002/07/owl#>
prefix rdf:       <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
prefix rdfs:      <http://www.w3.org/2000/01/rdf-schema#>
prefix respec:    <https://respec.org/model/>
prefix rule:      <https://www.javascript.fin.rijksweb.nl/model/rule/>
prefix section:   <https://www.javascript.fin.rijksweb.nl/model/section/>
prefix sh:        <http://www.w3.org/ns/shacl#>
prefix shp:       <https://www.javascript.fin.rijksweb.nl/model/shp/>
prefix skos:      <http://www.w3.org/2004/02/skos/core#>
prefix standard:  <https://www.javascript.fin.rijksweb.nl/model/>
prefix status:    <http://purl.org/adms/status/>
prefix target:    <https://www.javascript.fin.rijksweb.nl/model/target/>
prefix vann:      <http://purl.org/vocab/vann/>
prefix void:      <http://rdfs.org/ns/void#>
prefix xsd:       <http://www.w3.org/2001/XMLSchema#>

  js:
    a
      owl:Ontology,
      void:Dataset;
    dct:created '2024-09-29'^^xsd:date;
    dct:creator
      'Flores Bakker';
    dct:language 'iso639-1:en';
    dct:license 'http://creativecommons.org/licenses/by/4.0'^^xsd:anyURI;
    dct:publisher <https://rijksfinancien.nl>;
    dct:status status:UnderDevelopment;
    dct:subject 'Javascript'@en;
    dct:title 'Javascript Vocabulary'@en;
    dct:source <https://github.com/floresbakker/javascriptvoc>;
    
    dct:abstract """The Javascript Vocabulary provides a formal representation of the Javascript programming language, enabling the modeling and generation of Javascript code through an abstract syntax tree (AST) framework. It defines classes and properties to describe the various components of Javascript syntax, including functions, classes, statements, expressions, and data structures. Additionally, it incorporates SHACL shapes for validating Javascript code structures and supports algorithms for serializing Javascript code from RDF representations. This vocabulary enhances code generation and manipulation, bridging Javascript with broader semantic web technologies."""@en;

    dct:description """The Javascript Vocabulary formalizes the Javascript programming language, offering a structured representation of its syntax and semantics. It defines classes for different Javascript constructs, such as 'js:Statement' for statements, 'js:Function' for functions, and properties to capture relationships between these components. Central to this vocabulary is the class 'js:Node', which serves as a building block for all types of Javascript code segments. Each code unit can have attributes, such as 'js:operator' for operators within expressions and 'js:argument' for defining parameters. The vocabulary also includes SHACL shapes to validate the correctness of Javascript code structures, ensuring that generated code adheres to Javascript syntax rules. These shapes facilitate the creation of well-formed Javascript code that can be executed reliably. This comprehensive approach allows users to leverage RDF representations to generate Javascript code, enabling seamless integration of semantic technologies with programming tasks.
    
    The Javascript Core Vocabulary models the Javascript language based on its Abstract Syntax Tree (AST), as described in EStree[https://github.com/estree/estree]. 
    
"""@en;

    respec:introduction '''In todayâ€™s fast-paced development environment, the need for effective programming practices and tools is essential for managing code complexity. As organizations strive to maintain high-quality codebases, they face challenges related to code generation, validation, and reuse. The Javascript Vocabulary addresses these challenges by providing a structured framework to model and generate Javascript code through an abstract syntax tree representation, enhancing the agility, readability and reliability of programming practices.'''@en;

    respec:background '''The evolving landscape of software development demands tools that facilitate rapid code generation and validation, but safeguard the meaning and intent of the code. Javascript, with its rich ecosystem and diverse applications, requires robust frameworks to handle its syntax and semantics effectively. The complexity of Javascript constructs poses challenges for developers, particularly in ensuring compliance with best practices and coding standards, but also in explaining the logic of each program. The Javascript Vocabulary meets these challenges by offering a formalized structure for representing Javascript code, making it accessible now and in the future.'''@en;

    respec:objective '''To tackle the challenges of Javascript code generation, maintenance, reuse and validation, we present the Javascript Vocabulary - a transformative framework designed to support users in managing Javascript programming. This vocabulary enables users to (1) model and represent Javascript code constructs, (2) generate and validate Javascript code programmatically, and (3) ensure adherence to Javascript syntax and best practices. By leveraging the power of RDF and the flexibility of an abstract syntax tree, the Javascript Vocabulary enhances the efficiency and reliability of code generation in programming environments, fostering better coding practices and facilitating collaboration in software development projects.'''@en;

    respec:audience '''This document is intended for a diverse audience of software developers, data scientists, educators, and anyone involved in Javascript programming and code management. It aims to support users seeking to enhance their understanding and application of Javascript within the context of semantic technologies and code generation.'''@en;
    
    foaf:depiction 'https://www.rijksfinancien.nl/themes/custom/indicia_theme/files/logo-rijksoverheid.svg'^^xsd:anyURI;
    foaf:homepage 'https://www.rijksfinancien.nl/'^^xsd:anyURI;
    owl:imports
      dct:,
      owl:,
      rdf:,
      rdfs:,
      skos:;
    sh:declare
      decl:js,
      decl:rdf,
      decl:rdfs,
      decl:xsd;      
    owl:versionInfo '0.1.0';
    vann:preferredNamespacePrefix 'js';
    vann:preferredNamespaceUri 'https://www.javascript.fin.rijksweb.nl/model/def/';
    void:uriRegexPattern '^https://www.javascript.fin.rijksweb.nl/model/def/';
    void:uriSpace 'https://www.javascript.fin.rijksweb.nl/model/def/'^^xsd:anyURI;
    skos:example """

prefix ex:  <https://example.org/>
prefix js:  <https://www.javascript.fin.rijksweb.nl/model/def/>
prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>

# Root node of the AST (Program node)
ex:program1
  a js:Program ;
  js:body (ex:expressionStatement1) ;
  js:fragment '''console.log("Hello world!");'''.  

# ExpressionStatement
ex:expressionStatement1
  a js:ExpressionStatement ;
  js:expression ex:callExpression1;
  js:fragment '''console.log("Hello world!");'''.

# CallExpression node
ex:callExpression1
  a js:CallExpression ;
  js:callee    ex:memberExpression1 ;
  js:arguments (ex:argument1) ;
  js:fragment '''console.log("Hello world!")'''.  

# MemberExpression node
ex:memberExpression1
  a js:MemberExpression ;
  js:object   ex:identifierConsole ;
  js:property ex:identifierLog ;
  js:computed false;
  js:fragment '''console.log'''.

# Identifier object 'console'
ex:identifierConsole
  a js:Identifier ;
  js:name '''console''' ;
  js:fragment '''console'''.  

# Identifier property 'log'
ex:identifierLog
  a js:Identifier ;
  js:name '''log''';
  js:fragment '''log'''.

# Literal
ex:argument1
  a js:Literal ;
  js:value '''Hello world!''' ;
  js:raw '''\"hello world!\"''';
  js:fragment '''"Hello world!"'''.  

"""@en.

  decl:js
    sh:prefix "js";
    sh:namespace "https://www.javascript.fin.rijksweb.nl/model/def/"^^xsd:anyURI.

  decl:rdf
    sh:prefix "rdf";
    sh:namespace "http://www.w3.org/1999/02/22-rdf-syntax-ns#"^^xsd:anyURI.

  decl:rdfs
    sh:prefix "rdfs";
    sh:namespace "http://www.w3.org/2000/01/rdf-schema#"^^xsd:anyURI.

  decl:xsd
    sh:prefix "xsd";
    sh:namespace "http://www.w3.org/2001/XMLSchema#"^^xsd:anyURI.

  standard:javascript
    a dct:Standard;
    dct:created '2024-04-07'^^xsd:date;
    dct:source 'https://github.com/estree/estree'^^xsd:anyURI;
    skos:prefLabel 'Javascript'@en;
    rdfs:isDefinedBy js:. 

### Sections from the Javascript Specification ###
    
### Javascript voc ###

# class: Abstract Syntax Tree for Javascript 

js:AbstractSyntaxTree
  a owl:Class ;
  dct:conformsTo <http://example.org/section/AbstractSyntaxTree> ;
  skos:definition 'Represents a tree that models a Javascript program. It consists of a hierarchy of connected nodes that model the structure and syntax of a Javascript program.'@en ;
  skos:prefLabel 'Abstract Syntax Tree'@en ;
  rdfs:isDefinedBy js: .

js:Position
  a owl:Class ;
  dct:conformsTo <http://example.org/section/Position> ;
  skos:definition 'Represents a position within the Javascript abstract syntax tree.'@en ;
  skos:prefLabel 'Position'@en ;
  rdfs:isDefinedBy js: .

js:SourceLocation
  a owl:Class ;
  dct:conformsTo <http://example.org/section/SourceLocation> ;
  skos:definition 'Represents a source location within the Javascript abstract syntax tree.'@en ;
  skos:prefLabel 'Source location'@en ;
  rdfs:isDefinedBy js: .

js:Node
  a owl:Class ;
  dct:conformsTo <http://example.org/section/Node> ;
  skos:definition 'Represents an object within the Javascript abstract syntax tree.'@en ;
  skos:prefLabel 'Node'@en ;
  rdfs:isDefinedBy js: .

js:Program
  a owl:Class;
  rdfs:subClassOf js:Node;
  dct:conformsTo section:Program;
  skos:definition 'Represents a program in the Javascript syntax.'@en;
  skos:prefLabel 'Program'@en;
  rdfs:isDefinedBy js:.

js:Function
  a owl:Class;
  rdfs:subClassOf js:Node;
  dct:conformsTo section:Function;
  skos:definition 'Represents a function in the Javascript syntax.'@en;
  skos:prefLabel 'Function'@en;
  rdfs:isDefinedBy js:.

js:Statement
  a owl:Class;
  rdfs:subClassOf js:Node;
  dct:conformsTo section:Statement;
  skos:definition 'Represents a statement in the Javascript syntax.'@en;
  skos:prefLabel 'Statement'@en;
  rdfs:isDefinedBy js:.

js:Property
  a owl:Class;
  rdfs:subClassOf js:Node;
  dct:conformsTo section:Property;
  skos:definition 'Represents a property in the Javascript syntax.'@en;
  skos:prefLabel 'Property'@en;
  rdfs:isDefinedBy js:.

js:Pattern
  a owl:Class;
  rdfs:subClassOf js:Node;
  dct:conformsTo section:Pattern;
  skos:definition 'Represents a pattern in the Javascript syntax.'@en;
  skos:prefLabel 'Pattern'@en;
  rdfs:isDefinedBy js:.

js:ExpressionStatement
  a owl:Class ;
  rdfs:subClassOf js:Statement ;
  skos:prefLabel "Expression Statement"@en ;
  skos:definition "A statement that consists of a single expression."@en ;
  rdfs:isDefinedBy js: .

js:Directive
  a owl:Class ;
  rdfs:subClassOf js:ExpressionStatement ;
  skos:prefLabel "Directive"@en ;
  skos:definition "A directive statement."@en ;
  rdfs:isDefinedBy js: .

js:BlockStatement
  a owl:Class ;
  rdfs:subClassOf js:Statement ;
  skos:prefLabel "Block Statement"@en ;
  skos:definition "A block statement."@en ;
  rdfs:isDefinedBy js: .

js:EmptyStatement
  a owl:Class ;
  rdfs:subClassOf js:Statement ;
  skos:prefLabel "Empty Statement"@en ;
  skos:definition "An empty statement."@en ;
  rdfs:isDefinedBy js: .

js:DebuggerStatement
  a owl:Class ;
  rdfs:subClassOf js:Statement ;
  skos:prefLabel "Debugger Statement"@en ;
  skos:definition "A debugger statement."@en ;
  rdfs:isDefinedBy js: .

js:WithStatement
  a owl:Class ;
  rdfs:subClassOf js:Statement ;
  skos:prefLabel "With Statement"@en ;
  skos:definition "A with statement."@en ;
  rdfs:isDefinedBy js: .

js:ReturnStatement
  a owl:Class ;
  rdfs:subClassOf js:Statement ;
  skos:prefLabel "Return Statement"@en ;
  skos:definition "A return statement."@en ;
  rdfs:isDefinedBy js: .

js:LabeledStatement
  a owl:Class ;
  rdfs:subClassOf js:Statement ;
  skos:prefLabel "Labeled Statement"@en ;
  skos:definition "A labeled statement."@en ;
  rdfs:isDefinedBy js: .

js:BreakStatement
  a owl:Class ;
  rdfs:subClassOf js:Statement ;
  skos:prefLabel "Break Statement"@en ;
  skos:definition "A break statement."@en ;
  rdfs:isDefinedBy js: .

js:ContinueStatement
  a owl:Class ;
  rdfs:subClassOf js:Statement ;
  skos:prefLabel "Continue Statement"@en ;
  skos:definition "A continue statement."@en ;
  rdfs:isDefinedBy js: .

js:IfStatement
  a owl:Class ;
  rdfs:subClassOf js:Statement ;
  skos:prefLabel "If Statement"@en ;
  skos:definition "An if statement."@en ;
  rdfs:isDefinedBy js: .

js:SwitchStatement
  a owl:Class ;
  rdfs:subClassOf js:Statement ;
  skos:prefLabel "Switch Statement"@en ;
  skos:definition "A switch statement."@en ;
  rdfs:isDefinedBy js: .

js:ThrowStatement
  a owl:Class ;
  rdfs:subClassOf js:Statement ;
  skos:prefLabel "Throw Statement"@en ;
  skos:definition "A throw statement."@en ;
  rdfs:isDefinedBy js: .

js:TryStatement
  a owl:Class ;
  rdfs:subClassOf js:Statement ;
  skos:prefLabel "Try Statement"@en ;
  skos:definition "A try statement."@en ;
  rdfs:isDefinedBy js: .

js:WhileStatement
  a owl:Class ;
  rdfs:subClassOf js:Statement ;
  skos:prefLabel "While Statement"@en ;
  skos:definition "A while statement."@en ;
  rdfs:isDefinedBy js: .

js:DoWhileStatement
  a owl:Class ;
  rdfs:subClassOf js:Statement ;
  skos:prefLabel "Do While Statement"@en ;
  skos:definition "A do while statement."@en ;
  rdfs:isDefinedBy js: .

js:ForStatement
  a owl:Class ;
  rdfs:subClassOf js:Statement ;
  skos:prefLabel "For Statement"@en ;
  skos:definition "A for statement."@en ;
  rdfs:isDefinedBy js: .

js:ForInStatement
  a owl:Class ;
  rdfs:subClassOf js:Statement ;
  skos:prefLabel "For In Statement"@en ;
  skos:definition "A for in statement."@en ;
  rdfs:isDefinedBy js: .

js:Declaration
  a owl:Class ;
  rdfs:subClassOf js:Statement ;
  skos:prefLabel "Declaration"@en ;
  skos:definition "A declaration."@en ;
  rdfs:isDefinedBy js: .

js:VariableDeclaration
  a owl:Class ;
  rdfs:subClassOf js:Declaration ;
  skos:prefLabel "Variable declaration"@en ;
  skos:definition "A variable declaration."@en ;
  rdfs:isDefinedBy js: .

js:SwitchCase
  a owl:Class;
  rdfs:subClassOf js:Node;
  dct:conformsTo section:SwitchCase;
  skos:definition 'Represents a switch case statement in the Javascript syntax.'@en;
  skos:prefLabel 'Switch case'@en;
  rdfs:isDefinedBy js:.

js:CatchClause
  a owl:Class;
  rdfs:subClassOf js:Node;
  dct:conformsTo section:CatchClause;
  skos:definition 'Represents a catch clause statement in the Javascript syntax.'@en;
  skos:prefLabel 'Catch clause'@en;
  rdfs:isDefinedBy js:.

js:VariableDeclarator
  a owl:Class;
  rdfs:subClassOf js:Node;
  dct:conformsTo section:VariableDeclarator;
  skos:definition 'Represents a variable declarator in the Javascript syntax.'@en;
  skos:prefLabel 'Variable declarator'@en;
  rdfs:isDefinedBy js:.

js:Expression
  a owl:Class;
  rdfs:subClassOf js:Node;
  dct:conformsTo section:Expression;
  skos:definition 'Represents an expression in the Javascript syntax.'@en;
  skos:prefLabel 'Expression'@en;
  rdfs:isDefinedBy js:.

js:FunctionBody
  a owl:Class ;
  rdfs:subClassOf js:BlockStatement ;
  skos:prefLabel "Function body"@en ;
  skos:definition "A function body."@en ;
  rdfs:isDefinedBy js: .

js:ThisExpression
  a owl:Class ;
  rdfs:subClassOf js:Expression ;
  skos:prefLabel "This Expression"@en ;
  skos:definition "An expression representing 'this'."@en ;
  rdfs:isDefinedBy js: .

js:ArrayExpression
  a owl:Class ;
  rdfs:subClassOf js:Expression ;
  skos:prefLabel "Array Expression"@en ;
  skos:definition "An expression representing an array."@en ;
  rdfs:isDefinedBy js: .

js:ObjectExpression
  a owl:Class ;
  rdfs:subClassOf js:Expression ;
  skos:prefLabel "Object Expression"@en ;
  skos:definition "An expression representing an object."@en ;
  rdfs:isDefinedBy js: .

js:UnaryExpression
  a owl:Class ;
  rdfs:subClassOf js:Expression ;
  skos:prefLabel "Unary Expression"@en ;
  skos:definition "An expression representing an unary."@en ;
  rdfs:isDefinedBy js: .

js:UpdateExpression
  a owl:Class ;
  rdfs:subClassOf js:Expression ;
  skos:prefLabel "Update Expression"@en ;
  skos:definition "An expression representing an update."@en ;
  rdfs:isDefinedBy js: .

js:BinaryExpression
  a owl:Class ;
  rdfs:subClassOf js:Expression ;
  skos:prefLabel "Binary Expression"@en ;
  skos:definition "An expression representing a binary."@en ;
  rdfs:isDefinedBy js: .

js:AssignmentExpression
  a owl:Class ;
  rdfs:subClassOf js:Expression ;
  skos:prefLabel "Assignment Expression"@en ;
  skos:definition "An expression representing an assignment."@en ;
  rdfs:isDefinedBy js: .

js:LogicalExpression
  a owl:Class ;
  rdfs:subClassOf js:Expression ;
  skos:prefLabel "Logical Expression"@en ;
  skos:definition "A logical expression."@en ;
  rdfs:isDefinedBy js: .

js:ConditionalExpression
  a owl:Class ;
  rdfs:subClassOf js:Expression ;
  skos:prefLabel "Conditional Expression"@en ;
  skos:definition "An expression representing a conditional."@en ;
  rdfs:isDefinedBy js: .

js:CallExpression
  a owl:Class ;
  rdfs:subClassOf js:Expression ;
  skos:prefLabel "Call Expression"@en ;
  skos:definition "An expression representing a function or method call."@en ;
  rdfs:isDefinedBy js: .

js:NewExpression
  a owl:Class ;
  rdfs:subClassOf js:Expression ;
  skos:prefLabel "New Expression"@en ;
  skos:definition "A new expression."@en ;
  rdfs:isDefinedBy js: .

js:SequenceExpression
  a owl:Class ;
  rdfs:subClassOf js:Expression ;
  skos:prefLabel "Sequence Expression"@en ;
  skos:definition "An expression representing a sequence."@en ;
  rdfs:isDefinedBy js: .

js:MemberExpression
  a owl:Class ;
  rdfs:subClassOf js:Node ;
  owl:unionOf (js:Expression js:Pattern) ;
  skos:prefLabel "Member Expression"@en ;
  skos:definition "An expression accessing a property of an object."@en ;
  rdfs:isDefinedBy js: .

js:FunctionExpression
  a owl:Class ;
  rdfs:subClassOf js:Function, js:Expression ;
  skos:prefLabel "Function Expression"@en ;
  skos:definition "An expression calling a function."@en ;
  rdfs:isDefinedBy js: .

js:FunctionDeclaration
  a owl:Class ;
  rdfs:subClassOf js:Function, js:Declaration ;
  skos:prefLabel "Function Declaration"@en ;
  skos:definition "A function declaration."@en ;
  rdfs:isDefinedBy js: .

js:Identifier
  a owl:Class ;
  rdfs:subClassOf js:Node ;
  owl:unionOf (js:Expression js:Pattern) ;
  skos:prefLabel "Identifier"@en ;
  skos:definition "A terminal node representing a variable or function name."@en ;
  rdfs:isDefinedBy js: .

js:Literal
  a owl:Class ;
  rdfs:subClassOf js:Expression ;
  skos:prefLabel "Literal"@en ;
  skos:definition "A terminal node representing a fixed value like a string, number, or boolean."@en ;
  rdfs:isDefinedBy js: .

js:RegExpLiteral
  a owl:Class ;
  rdfs:subClassOf js:Literal ;
  owl:intersectionOf (js:Literal
                      [rdf:type owl:Restriction;
                       owl:onProperty js:regex;
                       owl:cardinality 1]);                      
  skos:prefLabel "RegExpLiteral"@en ;
  skos:definition "A terminal node representing a regex pattern."@en ;
  rdfs:isDefinedBy js: .

js:UnaryOperator a owl:Class ;
  owl:oneOf (
    "-"
    "+"
    "!"
    "~"
    "typeof"
    "void"
    "delete"
  ) ;
  skos:prefLabel "Unary Operator"@en ;
  skos:definition "A unary operator token used in a UnaryExpression."@en ;
  rdfs:isDefinedBy js: .

js:UpdateOperator a owl:Class ;
  owl:oneOf (
    "++"
    "--"
  ) ;
  skos:prefLabel "Update Operator"@en ;
  skos:definition "A update operator token used in a UpdateExpression."@en ;
  rdfs:isDefinedBy js: .

js:BinaryOperator a owl:Class ;
  owl:oneOf (
    "=="
    "!="
    "==="
    "!=="
    "<"
    "<="
    ">"
    ">="
    "<<"
    ">>"
    ">>>"
    "+"
    "-"
    "*"
    "/"
    "%"
    "|"
    "^"
    "&"
    "in"
    "instanceof"
    "**"
  ) ;
  skos:prefLabel "Binary Operator"@en ;
  skos:definition "A binary operator token used in a BinaryExpression."@en ;
  rdfs:isDefinedBy js: .

js:AssignmentOperator a owl:Class ;
  owl:oneOf (
    "="
    "+="
    "-="
    "*="
    "/="
    "%="
    "<<="
    ">>="
    ">>>="
    "|="
    "^="
    "&="
    "**="
    "||="
    "&&="
    "??="
  ) ;
  skos:prefLabel "Assignment Operator"@en ;
  skos:definition "An assignment operator token used in a AssignmentExpression."@en ;
  rdfs:isDefinedBy js: .

js:LogicalOperator a owl:Class ;
  owl:oneOf (
    "&&"
    "||"
    "??"
  ) ;
  skos:prefLabel "Logical Operator"@en ;
  skos:definition "A logical operator token used in a LogicalExpression."@en ;
  rdfs:isDefinedBy js: .
  
### Properties

js:node 
   rdf:type owl:ObjectProperty;
   skos:prefLabel 'node';
   skos:definition 'Superproperty to connect a parent node with a child node within an Abstract Syntax Tree of Javascript';
   rdfs:domain js:Node;
   rdfs:range js:Node.
   
js:body
   rdf:type owl:ObjectProperty;
   rdfs:subPropertyOf js:node;
   skos:prefLabel 'body';
   skos:definition 'body'.

js:id
   rdf:type owl:ObjectProperty;
   rdfs:subPropertyOf js:node;
   skos:prefLabel 'id';
   skos:definition 'id'.

js:expression
   rdf:type owl:ObjectProperty;
   rdfs:subPropertyOf js:node;
   skos:prefLabel 'expression';
   skos:definition 'expression'.

js:callee
   rdf:type owl:ObjectProperty;
   rdfs:subPropertyOf js:node;
   skos:prefLabel 'callee';
   skos:definition 'callee'.

js:arguments
   rdf:type owl:ObjectProperty;
   rdfs:subPropertyOf js:node;
   skos:prefLabel 'arguments';
   skos:definition 'arguments'.

js:object
   rdf:type owl:ObjectProperty;
   rdfs:subPropertyOf js:node;
   skos:prefLabel 'object';
   skos:definition 'object'.

js:property
   rdf:type owl:ObjectProperty;
   rdfs:subPropertyOf js:node;
   skos:prefLabel 'property';
   skos:definition 'property'.

js:operator
   rdf:type owl:ObjectProperty;
   rdfs:subPropertyOf js:node;
   skos:prefLabel 'operator';
   skos:definition 'operator'.

js:left
   rdf:type owl:ObjectProperty;
   rdfs:subPropertyOf js:node;
   skos:prefLabel 'left';
   skos:definition 'left'.

js:right
   rdf:type owl:ObjectProperty;
   rdfs:subPropertyOf js:node;
   skos:prefLabel 'right';
   skos:definition 'right'.

js:argument
   rdf:type owl:ObjectProperty;
   rdfs:subPropertyOf js:node;
   skos:prefLabel 'argument';
   skos:definition 'argument'.

js:value
   rdf:type owl:ObjectProperty;
   rdfs:subPropertyOf js:node;
   skos:prefLabel 'value';
   skos:definition 'value'.

js:key
   rdf:type owl:ObjectProperty;
   rdfs:subPropertyOf js:node;
   skos:prefLabel 'key';
   skos:definition 'key'.

js:properties
   rdf:type owl:ObjectProperty;
   rdfs:subPropertyOf js:node;
   skos:prefLabel 'properties';
   skos:definition 'properties'.

js:elements
   rdf:type owl:ObjectProperty;
   rdfs:subPropertyOf js:node;
   skos:prefLabel 'elements';
   skos:definition 'elements'.

js:init
   rdf:type owl:ObjectProperty;
   rdfs:subPropertyOf js:node;
   skos:prefLabel 'init';
   skos:definition 'init'.

js:declarations
   rdf:type owl:ObjectProperty;
   rdfs:subPropertyOf js:node;
   skos:prefLabel 'declarations';
   skos:definition 'declarations'.

js:test
   rdf:type owl:ObjectProperty;
   rdfs:subPropertyOf js:node;
   skos:prefLabel 'test';
   skos:definition 'test'.

js:update
   rdf:type owl:ObjectProperty;
   rdfs:subPropertyOf js:node;
   skos:prefLabel 'update';
   skos:definition 'update'.

js:param
   rdf:type owl:ObjectProperty;
   rdfs:subPropertyOf js:node;
   skos:prefLabel 'param';
   skos:definition 'param'.

js:block
   rdf:type owl:ObjectProperty;
   rdfs:subPropertyOf js:node;
   skos:prefLabel 'handler';
   skos:definition 'finalizer'.

js:consequent
   rdf:type owl:ObjectProperty;
   rdfs:subPropertyOf js:node;
   skos:prefLabel 'consequent';
   skos:definition 'consequent'.

js:discriminant
   rdf:type owl:ObjectProperty;
   rdfs:subPropertyOf js:node;
   skos:prefLabel 'discriminant';
   skos:definition 'discriminant'.

js:cases
   rdf:type owl:ObjectProperty;
   rdfs:subPropertyOf js:node;
   skos:prefLabel 'cases';
   skos:definition 'cases'.

js:alternate
   rdf:type owl:ObjectProperty;
   rdfs:subPropertyOf js:node;
   skos:prefLabel 'alternate';
   skos:definition 'alternate'.

js:label
   rdf:type owl:ObjectProperty;
   rdfs:subPropertyOf js:node;
   skos:prefLabel 'label';
   skos:definition 'label'.

js:directive
   rdf:type owl:ObjectProperty;
   rdfs:subPropertyOf js:node;
   skos:prefLabel 'directive';
   skos:definition 'directive'.

js:params
   rdf:type owl:ObjectProperty;
   rdfs:subPropertyOf js:node;
   skos:prefLabel 'params';
   skos:definition 'params'.

### Shapes ###

shp:Identifier
    a sh:NodeShape;
    sh:rule rule:Identifier;
    sh:target target:Identifier;
    skos:prefLabel 'Identifier shape'@en;
    rdfs:isDefinedBy js:.    

target:Identifier
    a sh:SPARQLTarget;
    rdfs:comment ''@en;
    sh:prefixes js:;
    sh:select '''
select $this {

  # Select all identifiers in the javascript logic...
  $this a/rdfs:subClassOf* js:Identifier.
  
  # ...that do not yet have a javascript fragment.
  filter not exists { $this js:fragment []. }
  
}''';
    rdfs:isDefinedBy js:.

rule:Identifier
    a sh:SPARQLRule;
    rdfs:comment ''@en;
    skos:prefLabel ''@en;
    sh:prefixes js:;
    sh:construct '''
construct {

  # Assert the new javascript fragment for this javascript node
  $this js:fragment ?fragment.
  
} where {
  
  $this js:name ?fragment.
  
}''';
    rdfs:isDefinedBy js:.

shp:Literal
    a sh:NodeShape;
    sh:rule rule:Literal;
    sh:target target:Literal;
    skos:prefLabel 'Literal shape'@en;
    rdfs:isDefinedBy js:.    

target:Literal
    a sh:SPARQLTarget;
    rdfs:comment ''@en;
    sh:prefixes js:;
    sh:select '''
select $this {

  # Select all literals in the javascript logic...
  $this a/rdfs:subClassOf* js:Literal.
  
  # ...that do not yet have a javascript fragment.
  filter not exists { $this js:fragment []. }
  
}''';
    rdfs:isDefinedBy js:.

rule:Literal
    a sh:SPARQLRule;
    rdfs:comment ''@en;
    skos:prefLabel ''@en;
    sh:prefixes js:;
    sh:construct '''
construct {

  # Assert the new javascript fragment for this javascript node
  $this js:fragment ?fragment.
  
} where {
  
  $this js:value ?valueFragment.
  
  optional {
  $this    js:regex   ?pattern, ?flags.
  ?pattern js:pattern ?patternString.
  ?flags   js:flags   ?flagsString.
  }
  bind(if(bound(?pattern), concat('"/', ?patternString, '/', ?flagsString,'"'), 
       if(datatype(?valueFragment)=xsd:string, concat('"',?valueFragment, '"'), ?valueFragment)) as ?fragment)
}''';
    rdfs:isDefinedBy js:.

shp:Program
    a sh:NodeShape;
    sh:rule rule:Program;
    sh:target target:Program;
    skos:prefLabel 'Program shape'@en;
    rdfs:isDefinedBy js:.

target:Program
    a sh:SPARQLTarget;
    rdfs:comment ''@en;
    sh:prefixes js:;
    sh:select '''
select $this {

  # Select all programs in the javascript AST...
  $this a/rdfs:subClassOf* js:Program.
  
  # ...that do not yet have a javascript fragment.
  filter not exists { $this js:fragment []. }
  
  # ...but whose body array elements already have a js:fragment
  filter not exists {
    $this js:body ?array.
    ?array rdf:first+ ?element.
    filter not exists { ?element js:fragment []. }
  }
}''';
    rdfs:isDefinedBy js:.

rule:Program
    a sh:SPARQLRule;
    rdfs:comment ''@en;
    skos:prefLabel ''@en;
    sh:prefixes js:;
    sh:construct '''
construct {

  # Assert the new javascript fragment for this javascript node
  $this js:fragment ?fragment.
  
} where {
  
  {select(group_concat(?elementFragment; separator="\n") as ?fragment)
  where {
  $this js:body ?array.
  ?array rdf:first+ ?element.
  ?element js:fragment ?elementFragment.
    }  
  }
}
''';
    rdfs:isDefinedBy js:.

shp:Function
    a sh:NodeShape;
    sh:rule rule:Function;
    sh:target target:Function;
    skos:prefLabel 'Function shape'@en;
    rdfs:isDefinedBy js:.

target:Function
    a sh:SPARQLTarget;
    rdfs:comment ''@en;
    sh:prefixes js:;
    sh:select '''
select $this {

  # Select all functions in the javascript AST...
  $this a/rdfs:subClassOf* js:Function.
  
  # ...that do not yet have a javascript fragment.
  filter not exists { $this js:fragment []. }

  # ...but whose identifier already has a js:fragment (or it is rdf:nil)
  filter not exists {
    $this js:id ?identifier.
    ?identifier rdf:type js:Identifier.
    filter not exists { ?identifier js:fragment []. }
  }

  # ...but whose params already have a js:fragment
  filter not exists {
    $this js:params ?array.
    ?array rdf:first ?pattern.
    ?pattern rdf:type js:Pattern.
    filter not exists { ?pattern js:fragment []. }
  }

  # ...but whose function body already has a js:fragment
  filter not exists {
    $this js:body ?functionBody.
    ?functionBody rdf:type js:FunctionBody.
    filter not exists { ?functionBody js:fragment []. }
  } 
}''';
    rdfs:isDefinedBy js:.

rule:Function
    a sh:SPARQLRule;
    rdfs:comment ''@en;
    skos:prefLabel ''@en;
    sh:prefixes js:;
    sh:construct '''
construct {

  # Assert the new javascript fragment for this javascript node
  $this js:fragment ?fragment.
  
} where {

  $this js:id ?identifier.
  ?identifier js:fragment ?identifierFragment.
  
  {select (group_concat(?patternFragment; separator=",") as ?paramsFragment)
     where {
     $this js:params ?array.
     ?array rdf:first+ ?pattern.
     ?pattern js:fragment ?patternFragment.
  }}
  
  $this js:body ?functionBody.
  ?functionBody rdf:type js:FunctionBody.
  ?functionBody js:fragment ?bodyFragment.
 
  bind(concat("function ",?identifierFragment,"(", ?paramsFragment, ")\n", "\t",?bodyFragment, "\n") as ?fragment)
}''';
    rdfs:isDefinedBy js:.

shp:ExpressionStatement
    a sh:NodeShape;
    sh:rule rule:ExpressionStatement;
    sh:target target:ExpressionStatement;
    skos:prefLabel 'ExpressionStatement shape'@en;
    rdfs:isDefinedBy js:.

target:ExpressionStatement
    a sh:SPARQLTarget;
    rdfs:comment ''@en;
    sh:prefixes js:;
    sh:select '''
select $this {

  # Select all expression statements in the javascript AST...
  $this a/rdfs:subClassOf* js:ExpressionStatement.
  
  # ...that do not yet have a javascript fragment.
  filter not exists { $this js:fragment []. }
  
  # ...but whose child node expression already has a js:fragment
  filter not exists {
    $this js:expression ?expression.
    filter not exists { ?expression js:fragment []. }
  }  
}''';
    rdfs:isDefinedBy js:.

rule:ExpressionStatement
    a sh:SPARQLRule;
    rdfs:comment ''@en;
    skos:prefLabel ''@en;
    sh:prefixes js:;
    sh:construct '''
construct {

  # Assert the new javascript fragment for this javascript node
  $this js:fragment ?fragment.
  
} where {
  
  $this js:expression ?expression.
  ?expression js:fragment ?expressionFragment.
  
  bind(concat(?expressionFragment, ";") as ?fragment)
  
}''';
    rdfs:isDefinedBy js:.

shp:Directive
    a sh:NodeShape;
    sh:rule rule:Directive;
    sh:target target:Directive;
    skos:prefLabel 'Directive shape'@en;
    rdfs:isDefinedBy js:.

target:Directive
    a sh:SPARQLTarget;
    rdfs:comment ''@en;
    sh:prefixes js:;
    sh:select '''
select $this {

  # Select all expression statements in the javascript AST...
  $this a/rdfs:subClassOf* js:Directive.
  
  # ...that do not yet have a javascript fragment.
  filter not exists { $this js:fragment []. }
 
}''';
    rdfs:isDefinedBy js:.

rule:Directive
    a sh:SPARQLRule;
    rdfs:comment ''@en;
    skos:prefLabel ''@en;
    sh:prefixes js:;
    sh:construct '''
construct {

  # Assert the new javascript fragment for this javascript node
  $this js:fragment ?fragment.
  
} where {
  
  $this js:value ?valueFragment.
  bind(if(datatype(?valueFragment)=xsd:string, concat('"',?valueFragment, '"'), ?valueFragment) as ?fragment)
}''';
    rdfs:isDefinedBy js:.

shp:BlockStatement
    a sh:NodeShape;
    sh:rule rule:BlockStatement;
    sh:target target:BlockStatement;
    skos:prefLabel 'BlockStatement shape'@en;
    rdfs:isDefinedBy js:.

target:BlockStatement
    a sh:SPARQLTarget;
    rdfs:comment ''@en;
    sh:prefixes js:;
    sh:select '''
select $this {

  # Select all block statements in the javascript AST...
  $this a/rdfs:subClassOf* js:BlockStatement.
  
  # ...that do not yet have a javascript fragment.
  filter not exists { $this js:fragment []. }
  
  # ...but whose body array elements already have a js:fragment
  filter not exists {
    $this js:body ?array.
    ?array rdf:first+ ?element.
    filter not exists { ?element js:fragment []. }
  }
}''';
    rdfs:isDefinedBy js:.

rule:BlockStatement
    a sh:SPARQLRule;
    rdfs:comment ''@en;
    skos:prefLabel ''@en;
    sh:prefixes js:;
    sh:construct '''
construct {

  # Assert the new javascript fragment for this javascript node
  $this js:fragment ?fragment.
  
} where {
   
  {select(group_concat(?elementFragment; separator="\n") as ?statementsFragment)
  where {
  $this js:body ?array.
  ?array rdf:first+ ?element.
  ?element js:fragment ?elementFragment.
    }
  }
  bind(concat("{\n", ?statementsFragment, "\n}") as ?fragment)
}''';
    rdfs:isDefinedBy js:.

shp:FunctionBody
    a sh:NodeShape;
    sh:rule rule:FunctionBody;
    sh:target target:FunctionBody;
    skos:prefLabel 'FunctionBody shape'@en;
    rdfs:isDefinedBy js:.

target:FunctionBody
    a sh:SPARQLTarget;
    rdfs:comment ''@en;
    sh:prefixes js:;
    sh:select '''
select $this {

  # Select all function bodies in the javascript AST...
  $this a/rdfs:subClassOf* js:FunctionBody.
  
  # ...that do not yet have a javascript fragment.
  filter not exists { $this js:fragment []. }
  
  # ...but whose body array elements already have a js:fragment
  filter not exists {
    $this js:body ?array.
    ?array rdf:first+ ?element.
    filter not exists { ?element js:fragment []. }
  }
}''';
    rdfs:isDefinedBy js:.

rule:FunctionBody
    a sh:SPARQLRule;
    rdfs:comment ''@en;
    skos:prefLabel ''@en;
    sh:prefixes js:;
    sh:construct '''
construct {

  # Assert the new javascript fragment for this javascript node
  $this js:fragment ?fragment.
  
} where {
   
  {select(group_concat(?elementFragment; separator="\n") as ?statementsFragment)
  where {
  $this js:body ?array.
  ?array rdf:first+ ?element.
  ?element js:fragment ?elementFragment.
    }
  }
  bind(concat("{\n", ?statementsFragment, "\n}") as ?fragment)
}''';
    rdfs:isDefinedBy js:.

shp:EmptyStatement
    a sh:NodeShape;
    sh:rule rule:EmptyStatement;
    sh:target target:EmptyStatement;
    skos:prefLabel 'EmptyStatement shape'@en;
    rdfs:isDefinedBy js:.

target:EmptyStatement
    a sh:SPARQLTarget;
    rdfs:comment ''@en;
    sh:prefixes js:;
    sh:select '''
select $this {

  # Select all empty statements in the javascript AST...
  $this a/rdfs:subClassOf* js:EmptyStatement.
  
  # ...that do not yet have a javascript fragment.
  filter not exists { $this js:fragment []. }

}''';
    rdfs:isDefinedBy js:.

rule:EmptyStatement
    a sh:SPARQLRule;
    rdfs:comment ''@en;
    skos:prefLabel ''@en;
    sh:prefixes js:;
    sh:construct '''
construct {

  # Assert the new javascript fragment for this javascript node
  $this js:fragment ";\n".
  
} where {}
''';
    rdfs:isDefinedBy js:.

shp:DebuggerStatement
    a sh:NodeShape;
    sh:rule rule:DebuggerStatement;
    sh:target target:DebuggerStatement;
    skos:prefLabel 'DebuggerStatement shape'@en;
    rdfs:isDefinedBy js:.

target:DebuggerStatement
    a sh:SPARQLTarget;
    rdfs:comment ''@en;
    sh:prefixes js:;
    sh:select '''
select $this {

  # Select all empty statements in the javascript AST...
  $this a/rdfs:subClassOf* js:DebuggerStatement.
  
  # ...that do not yet have a javascript fragment.
  filter not exists { $this js:fragment []. }

}''';
    rdfs:isDefinedBy js:.

rule:DebuggerStatement
    a sh:SPARQLRule;
    rdfs:comment ''@en;
    skos:prefLabel ''@en;
    sh:prefixes js:;
    sh:construct '''
construct {

  # Assert the new javascript fragment for this javascript node
  $this js:fragment "debugger;\n".
  
} where {}
''';
    rdfs:isDefinedBy js:.

shp:WithStatement
    a sh:NodeShape;
    sh:rule rule:WithStatement;
    sh:target target:WithStatement;
    skos:prefLabel 'WithStatement shape'@en;
    rdfs:isDefinedBy js:.

target:WithStatement
    a sh:SPARQLTarget;
    rdfs:comment ''@en;
    sh:prefixes js:;
    sh:select '''
select $this {

  # Select all with statements in the javascript AST...
  $this a/rdfs:subClassOf* js:WithStatement.
  
  # ...that do not yet have a javascript fragment.
  filter not exists { $this js:fragment []. }
  
  # ...but whose object already has a js:fragment
  filter not exists {
    $this js:object ?expression.
    filter not exists { ?expression js:fragment []. }
  }

  # ...but whose body already has a js:fragment.
  filter not exists {
    $this js:body ?statement.
    ?statement rdf:type/rdfs:subClassOf* js:Statement.
    filter not exists { ?statement js:fragment []. }
  } 
}''';
    rdfs:isDefinedBy js:.

rule:WithStatement
    a sh:SPARQLRule;
    rdfs:comment ''@en;
    skos:prefLabel ''@en;
    sh:prefixes js:;
    sh:construct '''
construct {

  # Assert the new javascript fragment for this javascript node
  $this js:fragment ?fragment.
  
} where {
  
  $this js:object ?object.
  ?object js:fragment ?objectFragment.
  
  $this js:body ?body.
  ?body js:fragment ?bodyFragment.
  
  bind(concat('with (', ?objectFragment,')  {', ?bodyFragment, '}') as ?fragment)
  
}''';
    rdfs:isDefinedBy js:.

shp:ReturnStatement
    a sh:NodeShape;
    sh:rule rule:ReturnStatement;
    sh:target target:ReturnStatement;
    skos:prefLabel 'ReturnStatement shape'@en;
    rdfs:isDefinedBy js:.

target:ReturnStatement
    a sh:SPARQLTarget;
    rdfs:comment ''@en;
    sh:prefixes js:;
    sh:select '''
select $this {

  # Select all return statements in the javascript AST...
  $this a/rdfs:subClassOf* js:ReturnStatement.
  
  # ...that do not yet have a javascript fragment.
  filter not exists { $this js:fragment []. }
  
  # ...but whose argument already has a js:fragment
  filter not exists {
    $this js:argument ?argument.
    ?argument rdf:type js:Statement.
    filter not exists { ?argument js:fragment []. }
  }
}''';
    rdfs:isDefinedBy js:.

rule:ReturnStatement
    a sh:SPARQLRule;
    rdfs:comment ''@en;
    skos:prefLabel ''@en;
    sh:prefixes js:;
    sh:construct '''
construct {

  # Assert the new javascript fragment for this javascript node
  $this js:fragment ?fragment.
  
} where {
  
  $this js:argument ?argument.
  
  # either returns a statement or null
  optional{
  ?argument js:fragment ?argumentFragment.}
    
  bind(concat('return ', coalesce(?argumentFragment, 'null;/n')) as ?fragment)
  
}''';
    rdfs:isDefinedBy js:.

shp:LabeledStatement
    a sh:NodeShape;
    sh:rule rule:LabeledStatement;
    sh:target target:LabeledStatement;
    skos:prefLabel 'LabeledStatement shape'@en;
    rdfs:isDefinedBy js:.

target:LabeledStatement
    a sh:SPARQLTarget;
    rdfs:comment ''@en;
    sh:prefixes js:;
    sh:select '''
select $this {

  # Select all labeled statements in the javascript AST...
  $this a/rdfs:subClassOf* js:LabeledStatement.
  
  # ...that do not yet have a javascript fragment.
  filter not exists { $this js:fragment []. }

  # ...but whose label already has a js:fragment
  filter not exists {
    $this js:label ?label.
    filter not exists { ?label js:fragment []. }
  }
  
  # ...and whose body statement already has a js:fragment
  filter not exists {
    $this js:body ?statement.
    filter not exists { ?statement js:fragment []. }
  }
}''';
    rdfs:isDefinedBy js:.

rule:LabeledStatement
    a sh:SPARQLRule;
    rdfs:comment ''@en;
    skos:prefLabel ''@en;
    sh:prefixes js:;
    sh:construct '''
construct {

  # Assert the new javascript fragment for this javascript node
  $this js:fragment ?fragment.
  
} where {
   
  $this js:label ?label.  
  ?label js:fragment ?labelFragment.       
  $this js:body ?statement.
  ?statement js:fragment ?statementFragment.
 
  bind(concat(?labelFragment, ": ", ?statementFragment) as ?fragment)
}''';
    rdfs:isDefinedBy js:.
    
shp:BreakStatement
    a sh:NodeShape;
    sh:rule rule:BreakStatement;
    sh:target target:BreakStatement;
    skos:prefLabel 'BreakStatement shape'@en;
    rdfs:isDefinedBy js:.

target:BreakStatement
    a sh:SPARQLTarget;
    rdfs:comment ''@en;
    sh:prefixes js:;
    sh:select '''
select $this {

  # Select all break statements in the javascript AST...
  $this a/rdfs:subClassOf* js:BreakStatement.
  
  # ...that do not yet have a javascript fragment.
  filter not exists { $this js:fragment []. }

  # ...but whose label already has a js:fragment
  filter not exists {
    $this js:label ?label.
    ?label rdf:type js:Identifier.
    filter not exists { ?label js:fragment []. }
  }
}''';
    rdfs:isDefinedBy js:.

rule:BreakStatement
    a sh:SPARQLRule;
    rdfs:comment ''@en;
    skos:prefLabel ''@en;
    sh:prefixes js:;
    sh:construct '''
construct {

  # Assert the new javascript fragment for this javascript node
  $this js:fragment ?fragment.
  
} where {

  optional {   
  $this js:label ?label.  
  ?label js:fragment ?labelFragment. }
 
  bind(concat("break ", coalesce(?labelFragment,""), ";") as ?fragment)
}''';
    rdfs:isDefinedBy js:.

shp:ContinueStatement
    a sh:NodeShape;
    sh:rule rule:ContinueStatement;
    sh:target target:ContinueStatement;
    skos:prefLabel 'ContinueStatement shape'@en;
    rdfs:isDefinedBy js:.

target:ContinueStatement
    a sh:SPARQLTarget;
    rdfs:comment ''@en;
    sh:prefixes js:;
    sh:select '''
select $this {

  # Select all continue statements in the javascript AST...
  $this a/rdfs:subClassOf* js:ContinueStatement.
  
  # ...that do not yet have a javascript fragment.
  filter not exists { $this js:fragment []. }

  # ...but whose label already has a js:fragment
  filter not exists {
    $this js:label ?label.
    ?label rdf:type js:Identifier.
    filter not exists { ?label js:fragment []. }
  }
}''';
    rdfs:isDefinedBy js:.

rule:ContinueStatement
    a sh:SPARQLRule;
    rdfs:comment ''@en;
    skos:prefLabel ''@en;
    sh:prefixes js:;
    sh:construct '''
construct {

  # Assert the new javascript fragment for this javascript node
  $this js:fragment ?fragment.
  
} where {

  optional {   
  $this js:label ?label.  
  ?label js:fragment ?labelFragment. }
 
  bind(concat("continue ", coalesce(?labelFragment,""), ";") as ?fragment)
}''';
    rdfs:isDefinedBy js:.

shp:IfStatement
    a sh:NodeShape;
    sh:rule rule:IfStatement;
    sh:target target:IfStatement;
    skos:prefLabel 'IfStatement shape'@en;
    rdfs:isDefinedBy js:.

target:IfStatement
    a sh:SPARQLTarget;
    rdfs:comment ''@en;
    sh:prefixes js:;
    sh:select '''
select $this {

  # Select all if statements in the javascript AST...
  $this a/rdfs:subClassOf* js:IfStatement.
  
  # ...that do not yet have a javascript fragment.
  filter not exists { $this js:fragment []. }

  # ...but whose test expression already has a js:fragment
  filter not exists {
    $this js:test ?test.
    filter not exists { ?test js:fragment []. }
  }

  # ...but whose consequent expression already has a js:fragment
  filter not exists {
    $this js:consequent ?consequent.
    filter not exists { ?consequent js:fragment []. }
  }  
  
  # ...and whose alternate statement already has a js:fragment (or is rdf:nil without js:fragment)
  filter not exists {
    $this js:alternate ?alternate.
    ?alternate rdf:type/rdfs:subClassOf* js:Statement.
    filter not exists { ?alternate js:fragment []. }
  }
}''';
    rdfs:isDefinedBy js:.

rule:IfStatement
    a sh:SPARQLRule;
    rdfs:comment ''@en;
    skos:prefLabel ''@en;
    sh:prefixes js:;
    sh:construct '''
construct {

  # Assert the new javascript fragment for this javascript node
  $this js:fragment ?fragment.
  
} where {
   
  $this js:test ?test.  
  ?test js:fragment ?testFragment.       
  $this js:consequent ?consequent.
  ?consequent js:fragment ?consequentFragment.
  $this js:alternate ?alternate.
  optional{
  ?alternate js:fragment ?alternateFragment.}
 
  bind(concat("if (",?testFragment, ")\n", "\t",?consequentFragment, "\n", if(bound(?alternateFragment), concat('else \n\t', ?alternateFragment),"\n"), "") as ?fragment)
}''';
    rdfs:isDefinedBy js:.

shp:SwitchStatement
    a sh:NodeShape;
    sh:rule rule:SwitchStatement;
    sh:target target:SwitchStatement;
    skos:prefLabel 'SwitchStatement shape'@en;
    rdfs:isDefinedBy js:.

target:SwitchStatement
    a sh:SPARQLTarget;
    rdfs:comment ''@en;
    sh:prefixes js:;
    sh:select '''
select $this {

  # Select all switch statements in the javascript AST...
  $this a/rdfs:subClassOf* js:SwitchStatement.
  
  # ...that do not yet have a javascript fragment.
  filter not exists { $this js:fragment []. }

  # ...but whose discriminant expression already has a js:fragment
  filter not exists {
    $this js:discriminant ?discriminant.
    filter not exists { ?discriminant js:fragment []. }
  }

  # ...and whose swtich cases already have a js:fragment 
  filter not exists {
    $this js:cases ?array.
    ?array rdf:first+ ?switchCase.
    ?switchCase rdf:type/rdfs:subClassOf* js:SwitchCase.
    filter not exists { ?switchCase js:fragment []. }
  }
}''';
    rdfs:isDefinedBy js:.

rule:SwitchStatement
    a sh:SPARQLRule;
    rdfs:comment ''@en;
    skos:prefLabel ''@en;
    sh:prefixes js:;
    sh:construct '''
construct {

  # Assert the new javascript fragment for this javascript node
  $this js:fragment ?fragment.
  
} where {
   
  $this js:discriminant ?discriminant.  
  ?discriminant js:fragment ?discriminantFragment.       
 
  {select (group_concat(?caseFragment; separator="\n") as ?casesFragment)
     where {
     $this js:cases ?array.
     ?array rdf:first+ ?switchCase.
     ?switchCase rdf:type/rdfs:subClassOf* js:SwitchCase.
     ?switchCase js:fragment ?caseFragment.
    }
   }

  bind(concat("(",?discriminantFragment, ") {\n", "\t", ?casesFragment, "}\n") as ?fragment)
}''';
    rdfs:isDefinedBy js:.

shp:SwitchCase
    a sh:NodeShape;
    sh:rule rule:SwitchCase;
    sh:target target:SwitchCase;
    skos:prefLabel 'SwitchCase shape'@en;
    rdfs:isDefinedBy js:.

target:SwitchCase
    a sh:SPARQLTarget;
    rdfs:comment ''@en;
    sh:prefixes js:;
    sh:select '''
select $this {

  # Select all switch cases in the javascript AST...
  $this a/rdfs:subClassOf* js:SwitchCase.
  
  # ...that do not yet have a javascript fragment.
  filter not exists { $this js:fragment []. }

  # ...but whose test expression already has a js:fragment
  filter not exists {
    $this js:test ?test.
    filter not exists { ?test js:fragment []. }
  }

  # ...but whose consequent expression already has a js:fragment
  filter not exists {
    $this js:consequent ?array.
    ?array rdf:first+ ?consequent.
    filter not exists { ?consequent js:fragment []. }
  }
}''';
    rdfs:isDefinedBy js:.

rule:SwitchCase
    a sh:SPARQLRule;
    rdfs:comment ''@en;
    skos:prefLabel ''@en;
    sh:prefixes js:;
    sh:construct '''
construct {

  # Assert the new javascript fragment for this javascript node
  $this js:fragment ?fragment.
  
} where {
   
  $this js:test ?test.  
  ?test js:fragment ?testFragment.       
 
  {select (group_concat(?consequentFragment; separator=";\n") as ?consequentsFragment)
     where {
     $this js:consequent ?array.
     ?array rdf:first+ ?consequent.
     ?consequent rdf:type/rdfs:subClassOf* js:Statement.
     ?consequent js:fragment ?consequentFragment.
    }
   }

  bind(concat("case ",?testFragment, ": \n", "\t", ?consequentsFragment, "\n") as ?fragment)
}''';
    rdfs:isDefinedBy js:.

shp:ThrowStatement
    a sh:NodeShape;
    sh:rule rule:ThrowStatement;
    sh:target target:ThrowStatement;
    skos:prefLabel 'ThrowStatement shape'@en;
    rdfs:isDefinedBy js:.

target:ThrowStatement
    a sh:SPARQLTarget;
    rdfs:comment ''@en;
    sh:prefixes js:;
    sh:select '''
select $this {

  # Select all throw statements in the javascript AST...
  $this a/rdfs:subClassOf* js:ThrowStatement.
  
  # ...that do not yet have a javascript fragment.
  filter not exists { $this js:fragment []. }
  
  # ...but whose argument already has a js:fragment
  filter not exists {
    $this js:argument ?argument.
    ?argument rdf:type js:Expression.
    filter not exists { ?argument js:fragment []. }
  }
}''';
    rdfs:isDefinedBy js:.

rule:ThrowStatement
    a sh:SPARQLRule;
    rdfs:comment ''@en;
    skos:prefLabel ''@en;
    sh:prefixes js:;
    sh:construct '''
construct {

  # Assert the new javascript fragment for this javascript node
  $this js:fragment ?fragment.
  
} where {
  
  $this js:argument ?argument.
  ?argument js:fragment ?argumentFragment.
    
  bind(concat('throw ', ?argumentFragment, ';/n') as ?fragment)
  
}''';
    rdfs:isDefinedBy js:.

shp:TryStatement
    a sh:NodeShape;
    sh:rule rule:TryStatement;
    sh:target target:TryStatement;
    skos:prefLabel 'TryStatement shape'@en;
    rdfs:isDefinedBy js:.

target:TryStatement
    a sh:SPARQLTarget;
    rdfs:comment ''@en;
    sh:prefixes js:;
    sh:select '''
select $this {

  # Select all try statements in the javascript AST...
  $this a/rdfs:subClassOf* js:TryStatement.
  
  # ...that do not yet have a javascript fragment.
  filter not exists { $this js:fragment []. }
  
  # ...but whose block statement already has a js:fragment
  filter not exists {
    $this js:block ?blockStatement.
    ?blockStatement rdf:type js:BlockStatement.
    filter not exists { ?blockStatement js:fragment []. }
  }

  # ...but whose optional handler catchclause already has a js:fragment
  filter not exists {
    $this js:handler ?catchClause.
    ?catchClause rdf:type js:CatchClause.
    filter not exists { ?catchClause js:fragment []. }
  }

  # ...but whose optional finalizer blockstatement already has a js:fragment
  filter not exists {
    $this js:finalizer ?finalizerBlockStatement.
    ?finalizerBlockStatement rdf:type js:BlockStatement.
    filter not exists { ?finalizerBlockStatement js:fragment []. }
  }  
}''';
    rdfs:isDefinedBy js:.

rule:TryStatement
    a sh:SPARQLRule;
    rdfs:comment ''@en;
    skos:prefLabel ''@en;
    sh:prefixes js:;
    sh:construct '''
construct {

  # Assert the new javascript fragment for this javascript node
  $this js:fragment ?fragment.
  
} where {
  
  $this js:block ?blockStatement.
  ?blockStatement 
     rdf:type js:BlockStatement;
     js:fragment ?blockFragment.

  $this js:handler ?catchClause.
  # catchClause might be rdf:nil  
  optional {   
  ?catchClause 
     rdf:type js:CatchClause;
     js:fragment ?catchFragment.}

  $this js:finalizer ?finalizerBlockStatement.
  # finalizer might be rdf:nil    
  optional {   
  ?finalizerBlockStatement
     rdf:type js:BlockStatement;
     js:fragment ?finalizerFragment.}
  bind(concat('try ', ?blockFragment, '\n', if(bound(?catchFragment), concat('\t', 'catch ',?catchFragment, '\n'), ''), if(bound(?finalizerFragment), concat('\t finally ', ?finalizerFragment, '\n'), '')) as ?fragment)
}
''';
    rdfs:isDefinedBy js:.    

shp:WhileStatement
    a sh:NodeShape;
    sh:rule rule:WhileStatement;
    sh:target target:WhileStatement;
    skos:prefLabel 'WhileStatement shape'@en;
    rdfs:isDefinedBy js:.

target:WhileStatement
    a sh:SPARQLTarget;
    rdfs:comment ''@en;
    sh:prefixes js:;
    sh:select '''
select $this {

  # Select all while statements in the javascript AST...
  $this a/rdfs:subClassOf* js:WhileStatement.
  
  # ...that do not yet have a javascript fragment.
  filter not exists { $this js:fragment []. }

  # ...but whose test expression already has a js:fragment
  filter not exists {
    $this js:test ?test.
    filter not exists { ?test js:fragment []. }
  }

  # ...but whose body statement already has a js:fragment
  filter not exists {
    $this js:body ?body.
    filter not exists { ?body js:fragment []. }
  }
}''';
    rdfs:isDefinedBy js:.

rule:WhileStatement
    a sh:SPARQLRule;
    rdfs:comment ''@en;
    skos:prefLabel ''@en;
    sh:prefixes js:;
    sh:construct '''
construct {

  # Assert the new javascript fragment for this javascript node
  $this js:fragment ?fragment.
  
} where {
   
  $this js:test ?test.  
  ?test js:fragment ?testFragment.       
  $this js:body ?body.
  ?body js:fragment ?bodyFragment.
 
  bind(concat("while (",?testFragment, ")\n", "\t",?bodyFragment, "\n") as ?fragment)
}''';
    rdfs:isDefinedBy js:.

shp:DoWhileStatement
    a sh:NodeShape;
    sh:rule rule:DoWhileStatement;
    sh:target target:DoWhileStatement;
    skos:prefLabel 'DoWhileStatement shape'@en;
    rdfs:isDefinedBy js:.

target:DoWhileStatement
    a sh:SPARQLTarget;
    rdfs:comment ''@en;
    sh:prefixes js:;
    sh:select '''
select $this {

  # Select all do while statements in the javascript AST...
  $this a/rdfs:subClassOf* js:DoWhileStatement.
  
  # ...that do not yet have a javascript fragment.
  filter not exists { $this js:fragment []. }

  # ...but whose test expression already has a js:fragment
  filter not exists {
    $this js:test ?test.
    filter not exists { ?test js:fragment []. }
  }

  # ...but whose body statement already has a js:fragment
  filter not exists {
    $this js:body ?body.
    filter not exists { ?body js:fragment []. }
  }
}''';
    rdfs:isDefinedBy js:.

rule:DoWhileStatement
    a sh:SPARQLRule;
    rdfs:comment ''@en;
    skos:prefLabel ''@en;
    sh:prefixes js:;
    sh:construct '''
construct {

  # Assert the new javascript fragment for this javascript node
  $this js:fragment ?fragment.
  
} where {
   
  $this js:test ?test.  
  ?test js:fragment ?testFragment.       
  $this js:body ?body.
  ?body js:fragment ?bodyFragment.
 
  bind(concat("do ",?bodyFragment, "\n", "\t while (",?testFragment, ")\n") as ?fragment)
}''';
    rdfs:isDefinedBy js:.

shp:ForStatement
    a sh:NodeShape;
    sh:rule rule:ForStatement;
    sh:target target:ForStatement;
    skos:prefLabel 'ForStatement shape'@en;
    rdfs:isDefinedBy js:.

target:ForStatement
    a sh:SPARQLTarget;
    rdfs:comment ''@en;
    sh:prefixes js:;
    sh:select '''
select $this {

  # Select all for statements in the javascript AST...
  $this a/rdfs:subClassOf* js:ForStatement.
  
  # ...that do not yet have a javascript fragment.
  filter not exists { $this js:fragment []. }

  # ...but whose init expression already has a js:fragment
  filter not exists {
    $this js:init ?init.
    filter not exists { ?init js:fragment []. }
  }
  
  # ...but whose test expression already has a js:fragment
  filter not exists {
    $this js:test ?test.
    filter not exists { ?test js:fragment []. }
  }

  # ...but whose update expression already has a js:fragment
  filter not exists {
    $this js:update ?update.
    filter not exists { ?update js:fragment []. }
  }
  
  # ...but whose body statement already has a js:fragment
  filter not exists {
    $this js:body ?body.
    filter not exists { ?body js:fragment []. }
  }
}''';
    rdfs:isDefinedBy js:.

rule:ForStatement
    a sh:SPARQLRule;
    rdfs:comment ''@en;
    skos:prefLabel ''@en;
    sh:prefixes js:;
    sh:construct '''
construct {

  # Assert the new javascript fragment for this javascript node
  $this js:fragment ?fragment.
  
} where {

  $this js:init ?init.  
  ?init js:fragment ?initFragment.     
  $this js:test ?test.  
  ?test js:fragment ?testFragment.  
  $this js:update ?update.  
  ?update js:fragment ?updateFragment.    
  $this js:body ?body.
  ?body js:fragment ?bodyFragment.
 
  bind(concat("for (",?initFragment, ";",?testFragment,";", ?updateFragment, ")\n", "\t",?bodyFragment, "\n") as ?fragment)
}''';
    rdfs:isDefinedBy js:.

shp:ForInStatement
    a sh:NodeShape;
    sh:rule rule:ForInStatement;
    sh:target target:ForInStatement;
    skos:prefLabel 'ForInStatement shape'@en;
    rdfs:isDefinedBy js:.

target:ForInStatement
    a sh:SPARQLTarget;
    rdfs:comment ''@en;
    sh:prefixes js:;
    sh:select '''
select $this {

  # Select all for in statements in the javascript AST...
  $this a/rdfs:subClassOf* js:ForInStatement.
  
  # ...that do not yet have a javascript fragment.
  filter not exists { $this js:fragment []. }

  # ...but whose left expression already has a js:fragment
  filter not exists {
    $this js:left ?left.
    filter not exists { ?left js:fragment []. }
  }
  
  # ...but whose right expression already has a js:fragment
  filter not exists {
    $this js:right ?right.
    filter not exists { ?right js:fragment []. }
  }
  
  # ...but whose body statement already has a js:fragment
  filter not exists {
    $this js:body ?body.
    filter not exists { ?body js:fragment []. }
  }
}''';
    rdfs:isDefinedBy js:.

rule:ForInStatement
    a sh:SPARQLRule;
    rdfs:comment ''@en;
    skos:prefLabel ''@en;
    sh:prefixes js:;
    sh:construct '''
construct {

  # Assert the new javascript fragment for this javascript node
  $this js:fragment ?fragment.
  
} where {

  $this js:left ?left.  
  ?left js:fragment ?leftFragment.     
  $this js:right ?right.  
  ?right js:fragment ?rightFragment.  
  $this js:body ?body.
  ?body js:fragment ?bodyFragment.
 
  bind(concat("for (",?leftFragment," in ", ?rightFragment, ")\n", "\t",?bodyFragment, "\n") as ?fragment)
}''';
    rdfs:isDefinedBy js:.

shp:VariableDeclaration
    a sh:NodeShape;
    sh:rule rule:VariableDeclaration;
    sh:target target:VariableDeclaration;
    skos:prefLabel 'VariableDeclaration shape'@en;
    rdfs:isDefinedBy js:.

target:VariableDeclaration
    a sh:SPARQLTarget;
    rdfs:comment ''@en;
    sh:prefixes js:;
    sh:select '''
select $this {

  # Select all variable declarations in the javascript AST...
  $this a/rdfs:subClassOf* js:VariableDeclaration.
  
  # ...that do not yet have a javascript fragment.
  filter not exists { $this js:fragment []. }

  # ...but whose declarations already has a js:fragment
  filter not exists {
    $this js:declarations ?array.
    ?array rdf:first ?variableDeclarator.
    filter not exists { ?variableDeclarator js:fragment []. }
  }
}''';
    rdfs:isDefinedBy js:.

rule:VariableDeclaration
    a sh:SPARQLRule;
    rdfs:comment ''@en;
    skos:prefLabel ''@en;
    sh:prefixes js:;
    sh:construct '''
construct {

  # Assert the new javascript fragment for this javascript node
  $this js:fragment ?fragment.
  
} where {


  {select (group_concat(?varDeclaratorFragment; separator=", ") as ?declarationsFragment)
     where {
     $this js:declarations ?array.
     ?array rdf:first+ ?varDeclarator.
     ?varDeclarator rdf:type/rdfs:subClassOf* js:VariableDeclarator;
                    js:fragment ?varDeclaratorFragment.
    }
   }
 
  $this js:kind ?kind.              
 
  bind(concat(?kind," ",?declarationsFragment, "\n") as ?fragment)
}''';
    rdfs:isDefinedBy js:.

shp:VariableDeclarator
    a sh:NodeShape;
    sh:rule rule:VariableDeclarator;
    sh:target target:VariableDeclarator;
    skos:prefLabel 'VariableDeclarator shape'@en;
    rdfs:isDefinedBy js:.

target:VariableDeclarator
    a sh:SPARQLTarget;
    rdfs:comment ''@en;
    sh:prefixes js:;
    sh:select '''
select $this {

  # Select all variable declarators in the javascript AST...
  $this a/rdfs:subClassOf* js:VariableDeclarator.
  
  # ...that do not yet have a javascript fragment.
  filter not exists { $this js:fragment []. }

  # ...but whose identifier already has a js:fragment
  filter not exists {
    $this js:id ?pattern.
    ?pattern rdf:type js:Pattern.
    filter not exists { ?pattern js:fragment []. }
  }
  
  # ...and whose init already has a js:fragment (or is rdf:nil)
  filter not exists {
    $this js:init ?expression.
    ?expression rdf:type/rdfs:subClassOf* js:Expression.
    filter not exists { ?expression js:fragment []. }
  }
}''';
    rdfs:isDefinedBy js:.

rule:VariableDeclarator
    a sh:SPARQLRule;
    rdfs:comment ''@en;
    skos:prefLabel ''@en;
    sh:prefixes js:;
    sh:construct '''
construct {

  # Assert the new javascript fragment for this javascript node
  $this js:fragment ?fragment.
  
} where {

  $this js:id ?pattern.
  ?pattern rdf:type js:Pattern;
           js:fragment ?identifierFragment.

  $this js:init ?expression.
  OPTIONAL
  {?expression rdf:type/rdfs:subClassOf* js:Expression;
              js:fragment ?initFragment.}
               
  bind(concat(?identifierFragment," = ",?initFragment, ";") as ?fragment)
}''';
    rdfs:isDefinedBy js:.

shp:ThisExpression
    a sh:NodeShape;
    sh:rule rule:ThisExpression;
    sh:target target:ThisExpression;
    skos:prefLabel 'ThisExpression shape'@en;
    rdfs:isDefinedBy js:.

target:ThisExpression
    a sh:SPARQLTarget;
    rdfs:comment ''@en;
    sh:prefixes js:;
    sh:select '''
select $this {

  # Select all this expressions in the javascript AST...
  $this a/rdfs:subClassOf* js:ThisExpression.
  
  # ...that do not yet have a javascript fragment.
  filter not exists { $this js:fragment []. }
}''';
    rdfs:isDefinedBy js:.

rule:ThisExpression
    a sh:SPARQLRule;
    rdfs:comment ''@en;
    skos:prefLabel ''@en;
    sh:prefixes js:;
    sh:construct '''
construct {

  # Assert the new javascript fragment for this javascript node
  $this js:fragment "this".
  
} where {}
''';
    rdfs:isDefinedBy js:.

shp:ArrayExpression
    a sh:NodeShape;
    sh:rule rule:ArrayExpression;
    sh:target target:ArrayExpression;
    skos:prefLabel 'ArrayExpression shape'@en;
    rdfs:isDefinedBy js:.

target:ArrayExpression
    a sh:SPARQLTarget;
    rdfs:comment ''@en;
    sh:prefixes js:;
    sh:select '''
select $this {

  # Select all array expressions in the javascript AST...
  $this a/rdfs:subClassOf* js:ArrayExpression.
  
  # ...that do not yet have a javascript fragment.
  filter not exists { $this js:fragment []. }
  
  # ...but whose elements already have a js:fragment (or are rdf:nil)
  filter not exists {
    $this js:elements ?array.
    ?array rdf:first+ ?expression.
    ?expression rdf:type/rdfs:subClassOf* js:Expression.
    filter not exists { ?expression js:fragment []. }
  }
}''';
    rdfs:isDefinedBy js:.

rule:ArrayExpression
    a sh:SPARQLRule;
    rdfs:comment ''@en;
    skos:prefLabel ''@en;
    sh:prefixes js:;
    sh:construct '''
construct {

  # Assert the new javascript fragment for this javascript node
  $this js:fragment ?fragment.
  
} where {

  {select (group_concat(?elementFragment; separator=",") as ?arrayFragment)
   where {
    $this js:elements ?array.
    ?array rdf:first+ ?expression.
    optional{
    ?expression rdf:type/rdfs:subClassOf* js:Expression.
    ?expression js:fragment ?expressionFragment.}
    bind(coalesce(?expressionFragment, "") as ?elementFragment)
    }
  }
  bind(concat("[",?arrayFragment, "]") as ?fragment)
}
''';
    rdfs:isDefinedBy js:.    

shp:ObjectExpression
    a sh:NodeShape;
    sh:rule rule:ObjectExpression;
    sh:target target:ObjectExpression;
    skos:prefLabel 'ObjectExpression shape'@en;
    rdfs:isDefinedBy js:.

target:ObjectExpression
    a sh:SPARQLTarget;
    rdfs:comment ''@en;
    sh:prefixes js:;
    sh:select '''
select $this {

  # Select all object expressions in the javascript AST...
  $this a/rdfs:subClassOf* js:ObjectExpression.
  
  # ...that do not yet have a javascript fragment.
  filter not exists { $this js:fragment []. }
  
  # ...but whose properties already have a js:fragment
  filter not exists {
    $this js:properties ?array.
    ?array rdf:first+ ?property.
    ?property rdf:type/rdfs:subClassOf* js:Property.
    filter not exists { ?property js:fragment []. }
  }
}''';
    rdfs:isDefinedBy js:.

rule:ObjectExpression
    a sh:SPARQLRule;
    rdfs:comment ''@en;
    skos:prefLabel ''@en;
    sh:prefixes js:;
    sh:construct '''
construct {

  # Assert the new javascript fragment for this javascript node
  $this js:fragment ?fragment.
  
} where {

  {select (group_concat(?propertyFragment; separator=",") as ?arrayFragment)
   where {
    $this js:properties ?array.
    ?array rdf:first+ ?property.
    ?property rdf:type/rdfs:subClassOf* js:Property.
    ?expression js:fragment ?propertyFragment.
    }
   }
  bind(concat(?propertyFragment, ",") as ?fragment)
}
''';
    rdfs:isDefinedBy js:. 

shp:Property
    a sh:NodeShape;
    sh:rule rule:Property;
    sh:target target:Property;
    skos:prefLabel 'Property shape'@en;
    rdfs:isDefinedBy js:.

target:Property
    a sh:SPARQLTarget;
    rdfs:comment ''@en;
    sh:prefixes js:;
    sh:select '''
select $this {

  # Select all properties in the javascript AST...
  $this a/rdfs:subClassOf* js:Property.
  
  # ...that do not yet have a javascript fragment.
  filter not exists { $this js:fragment []. }
  
  # ...but whose key already has a js:fragment
  filter not exists {
    $this js:key ?key.
    filter not exists { ?key js:fragment []. }
  }

  # ...but whose value already has a js:fragment
  filter not exists {
    $this js:value ?value.
    ?value rdf:type/rdfs:subClassOf* js:Expression.
    filter not exists { ?value js:fragment []. }
  }
}''';
    rdfs:isDefinedBy js:.

rule:Property
    a sh:SPARQLRule;
    rdfs:comment ''@en;
    skos:prefLabel ''@en;
    sh:prefixes js:;
    sh:construct '''
construct {

  # Assert the new javascript fragment for this javascript node
  $this js:fragment ?fragment.
  
} where {

  $this js:key ?key;
        js:fragment ?keyFragment.
    
  $this js:value ?value.
  ?value rdf:type/rdfs:subClassOf* js:Expression;
         js:fragment ?valueFragment.

  $this js:kind ?kind.
  
  bind(if(?kind = 'init', concat(?keyFragment, ':', ?valueFragment, ','), concat(?kind, ' ', ?keyFragment, ' \n', ?valueFragment)) as ?fragment)
}
''';
    rdfs:isDefinedBy js:. 

shp:UnaryExpression
    a sh:NodeShape;
    sh:rule rule:UnaryExpression;
    sh:target target:UnaryExpression;
    skos:prefLabel 'UnaryExpression shape'@en;
    rdfs:isDefinedBy js:.

target:UnaryExpression
    a sh:SPARQLTarget;
    rdfs:comment ''@en;
    sh:prefixes js:;
    sh:select '''
select $this {

  # Select all unary expressions in the javascript AST...
  $this a/rdfs:subClassOf* js:UnaryExpression.
  
  # ...that do not yet have a javascript fragment.
  filter not exists { $this js:fragment []. }

  # ...but whose value already has a js:fragment
  filter not exists {
    $this js:argument ?argument.
    ?argument rdf:type/rdfs:subClassOf* js:Expression.
    filter not exists { ?argument js:fragment []. }
  }
}''';
    rdfs:isDefinedBy js:.

rule:UnaryExpression
    a sh:SPARQLRule;
    rdfs:comment ''@en;
    skos:prefLabel ''@en;
    sh:prefixes js:;
    sh:construct '''
construct {

  # Assert the new javascript fragment for this javascript node
  $this js:fragment ?fragment.
  
} where {

  $this 
    js:operator ?operator;
    js:prefix ?boolean;
    js:argument ?argument.
  
  ?argument 
    rdf:type/rdfs:subClassOf* js:Expression;
    js:fragment ?argumentFragment.

  bind(if(?boolean, concat(?operator, ' ', ?argumentFragment), concat(?argumentFragment, ' ', ?operator)) as ?fragment)
}
''';
    rdfs:isDefinedBy js:. 

shp:UpdateExpression
    a sh:NodeShape;
    sh:rule rule:UpdateExpression;
    sh:target target:UpdateExpression;
    skos:prefLabel 'UpdateExpression shape'@en;
    rdfs:isDefinedBy js:.

target:UpdateExpression
    a sh:SPARQLTarget;
    rdfs:comment ''@en;
    sh:prefixes js:;
    sh:select '''
select $this {

  # Select all update expressions in the javascript AST...
  $this a/rdfs:subClassOf* js:UpdateExpression.
  
  # ...that do not yet have a javascript fragment.
  filter not exists { $this js:fragment []. }

  # ...but whose value already has a js:fragment
  filter not exists {
    $this js:argument ?argument.
    ?argument rdf:type/rdfs:subClassOf* js:Expression.
    filter not exists { ?argument js:fragment []. }
  }
}''';
    rdfs:isDefinedBy js:.

rule:UpdateExpression
    a sh:SPARQLRule;
    rdfs:comment ''@en;
    skos:prefLabel ''@en;
    sh:prefixes js:;
    sh:construct '''
construct {

  # Assert the new javascript fragment for this javascript node
  $this js:fragment ?fragment.
  
} where {

  $this 
    js:operator ?operator;
    js:prefix ?boolean;
    js:argument ?argument.
  
  ?argument 
    rdf:type/rdfs:subClassOf* js:Expression;
    js:fragment ?argumentFragment.

  bind(if(?boolean, concat(?operator, ' ', ?argumentFragment), concat(?argumentFragment, ' ', ?operator)) as ?fragment)
}
''';
    rdfs:isDefinedBy js:.

shp:BinaryExpression
    a sh:NodeShape;
    sh:rule rule:BinaryExpression;
    sh:target target:BinaryExpression;
    skos:prefLabel 'BinaryExpression shape'@en;
    rdfs:isDefinedBy js:.

target:BinaryExpression
    a sh:SPARQLTarget;
    rdfs:comment ''@en;
    sh:prefixes js:;
    sh:select '''
select $this {

  # Select all binary expressions in the javascript AST...
  $this a/rdfs:subClassOf* js:BinaryExpression.
  
  # ...that do not yet have a javascript fragment.
  filter not exists { $this js:fragment []. }

  # ...but whose left operand already has a js:fragment
  filter not exists {
    $this js:left ?left.
    ?left rdf:type/rdfs:subClassOf* js:Expression.
    filter not exists { ?left js:fragment []. }
  }

  # ...but whose right operand already has a js:fragment
  filter not exists {
    $this js:right ?right.
    ?right rdf:type/rdfs:subClassOf* js:Expression.
    filter not exists { ?right js:fragment []. }
  }
}''';
    rdfs:isDefinedBy js:.

rule:BinaryExpression
    a sh:SPARQLRule;
    rdfs:comment ''@en;
    skos:prefLabel ''@en;
    sh:prefixes js:;
    sh:construct '''
construct {

  # Assert the new javascript fragment for this javascript node
  $this js:fragment ?fragment.
  
} where {

  $this 
    js:operator ?operator;
    js:left ?left;
    js:right ?right.
  
  ?left
    rdf:type/rdfs:subClassOf* js:Expression;
    js:fragment ?leftFragment.

  ?right
    rdf:type/rdfs:subClassOf* js:Expression;
    js:fragment ?rightFragment.

  bind(concat(?leftFragment, ' ', ?operator, ' ', ?rightFragment) as ?fragment)
}
''';
    rdfs:isDefinedBy js:.

shp:AssignmentExpression
    a sh:NodeShape;
    sh:rule rule:AssignmentExpression;
    sh:target target:AssignmentExpression;
    skos:prefLabel 'AssignmentExpression shape'@en;
    rdfs:isDefinedBy js:.

target:AssignmentExpression
    a sh:SPARQLTarget;
    rdfs:comment ''@en;
    sh:prefixes js:;
    sh:select '''
select $this {

  # Select all assignment expressions in the javascript AST...
  $this a/rdfs:subClassOf* js:AssignmentExpression.
  
  # ...that do not yet have a javascript fragment.
  filter not exists { $this js:fragment []. }

  # ...but whose left operand already has a js:fragment
  filter not exists {
    $this js:left ?left.
    filter not exists { ?left js:fragment []. }
  }

  # ...but whose right operand already has a js:fragment
  filter not exists {
    $this js:right ?right.
    ?right rdf:type/rdfs:subClassOf* js:Expression.
    filter not exists { ?right js:fragment []. }
  }
}''';
    rdfs:isDefinedBy js:.

rule:AssignmentExpression
    a sh:SPARQLRule;
    rdfs:comment ''@en;
    skos:prefLabel ''@en;
    sh:prefixes js:;
    sh:construct '''
construct {

  # Assert the new javascript fragment for this javascript node
  $this js:fragment ?fragment.
  
} where {

  $this 
    js:operator ?operator;
    js:left ?left;
    js:right ?right.
  
  ?left
    js:fragment ?leftFragment.

  ?right
    rdf:type/rdfs:subClassOf* js:Expression;
    js:fragment ?rightFragment.

  bind(concat(?leftFragment, ' ', ?operator, ' ', ?rightFragment) as ?fragment)
}
''';
    rdfs:isDefinedBy js:.

shp:LogicalExpression
    a sh:NodeShape;
    sh:rule rule:LogicalExpression;
    sh:target target:LogicalExpression;
    skos:prefLabel 'LogicalExpression shape'@en;
    rdfs:isDefinedBy js:.

target:LogicalExpression
    a sh:SPARQLTarget;
    rdfs:comment ''@en;
    sh:prefixes js:;
    sh:select '''
select $this {

  # Select all logical expressions in the javascript AST...
  $this a/rdfs:subClassOf* js:LogicalExpression.
  
  # ...that do not yet have a javascript fragment.
  filter not exists { $this js:fragment []. }

  # ...but whose left operand already has a js:fragment
  filter not exists {
    $this js:left ?left.
    ?left rdf:type/rdfs:subClassOf* js:Expression.    
    filter not exists { ?left js:fragment []. }
  }

  # ...but whose right operand already has a js:fragment
  filter not exists {
    $this js:right ?right.
    ?right rdf:type/rdfs:subClassOf* js:Expression.
    filter not exists { ?right js:fragment []. }
  }
}''';
    rdfs:isDefinedBy js:.

rule:LogicalExpression
    a sh:SPARQLRule;
    rdfs:comment ''@en;
    skos:prefLabel ''@en;
    sh:prefixes js:;
    sh:construct '''
construct {

  # Assert the new javascript fragment for this javascript node
  $this js:fragment ?fragment.
  
} where {

  $this 
    js:operator ?operator;
    js:left ?left;
    js:right ?right.
  
  ?left
    rdf:type/rdfs:subClassOf* js:Expression;
    js:fragment ?leftFragment.

  ?right
    rdf:type/rdfs:subClassOf* js:Expression;
    js:fragment ?rightFragment.

  bind(concat(?leftFragment, ' ', ?operator, ' ', ?rightFragment) as ?fragment)
}
''';
    rdfs:isDefinedBy js:.

shp:ConditionalExpression
    a sh:NodeShape;
    sh:rule rule:ConditionalExpression;
    sh:target target:ConditionalExpression;
    skos:prefLabel 'ConditionalExpression shape'@en;
    rdfs:isDefinedBy js:.

target:ConditionalExpression
    a sh:SPARQLTarget;
    rdfs:comment ''@en;
    sh:prefixes js:;
    sh:select '''
select $this {

  # Select all conditional expressions in the javascript AST...
  $this a/rdfs:subClassOf* js:ConditionalExpression.
  
  # ...that do not yet have a javascript fragment.
  filter not exists { $this js:fragment []. }

  # ...but whose test expression already has a js:fragment
  filter not exists {
    $this js:test ?test.
    ?test rdf:type/rdfs:subClassOf* js:Expression.    
    filter not exists { ?test js:fragment []. }
  }

  # ...and whose alternate expression already has a js:fragment
  filter not exists {
    $this js:alternate ?alternate.
    ?alternate rdf:type/rdfs:subClassOf* js:Expression.
    filter not exists { ?alternate js:fragment []. }
  }

  # ...and whose consequent expression already has a js:fragment
  filter not exists {
    $this js:consequent ?consequent.
    ?consequent rdf:type/rdfs:subClassOf* js:Expression.
    filter not exists { ?consequent js:fragment []. }
  }
}''';
    rdfs:isDefinedBy js:.

rule:ConditionalExpression
    a sh:SPARQLRule;
    rdfs:comment ''@en;
    skos:prefLabel ''@en;
    sh:prefixes js:;
    sh:construct '''
construct {

  # Assert the new javascript fragment for this javascript node
  $this js:fragment ?fragment.
  
} where {

  $this js:test ?test.
  ?test rdf:type/rdfs:subClassOf* js:Expression;
        js:fragment ?testFragment.

  $this js:consequent ?consequent.
  ?consequent rdf:type/rdfs:subClassOf* js:Expression;
              js:fragment ?consequentFragment.

  $this js:alternate ?alternate.
  ?alternate rdf:type/rdfs:subClassOf* js:Expression;
             js:fragment ?alternateFragment.

  bind(concat(?testFragment, ' ? ', ?consequentFragment, ' : ', ?alternateFragment) as ?fragment)
}
''';
    rdfs:isDefinedBy js:.

shp:MemberExpression
    a sh:NodeShape;
    sh:rule rule:MemberExpression;
    sh:target target:MemberExpression;
    skos:prefLabel 'MemberExpression shape'@en;
    rdfs:isDefinedBy js:.

target:MemberExpression
    a sh:SPARQLTarget;
    rdfs:comment ''@en;
    sh:prefixes js:;
    sh:select '''
select $this {

  # Select all member expressions in the javascript AST...
  $this a/rdfs:subClassOf* js:MemberExpression.
  
  # ...that do not yet have a javascript fragment.
  filter not exists { $this js:fragment []. }
  
  # ...but whose object already has a js:fragment
  filter not exists {
    $this js:object ?expression.
    filter not exists { ?expression js:fragment []. }
  }

  # ...but whose property already has a js:fragment
  filter not exists {
    $this js:property ?expression.
    filter not exists { ?expression js:fragment []. }
  } 
}''';
    rdfs:isDefinedBy js:.

rule:MemberExpression
    a sh:SPARQLRule;
    rdfs:comment ''@en;
    skos:prefLabel ''@en;
    sh:prefixes js:;
    sh:construct '''
construct {

  # Assert the new javascript fragment for this javascript node
  $this js:fragment ?fragment.
  
} where {
  
  $this js:computed ?computed.
  $this js:object ?object.
  ?object js:fragment ?objectFragment.
  
  OPTIONAL{
  $this js:property ?property.
  ?property js:fragment ?propertyFragment.
  }
  
  bind(if(?computed, concat(?objectFragment, "[", ?propertyFragment, "]"), 
                     concat(?objectFragment, ".", ?propertyFragment)) 
  as ?fragment)
  
}''';
    rdfs:isDefinedBy js:.

shp:CallExpression
    a sh:NodeShape;
    sh:rule rule:CallExpression;
    sh:target target:CallExpression;
    skos:prefLabel 'CallExpression shape'@en;
    rdfs:isDefinedBy js:.

target:CallExpression
    a sh:SPARQLTarget;
    rdfs:comment ''@en;
    sh:prefixes js:;
    sh:select '''
select $this {

  # Select all call expressions in the javascript AST...
  $this a/rdfs:subClassOf* js:CallExpression.
  
  # ...that do not yet have a javascript fragment.
  filter not exists { $this js:fragment []. }
  
  # ...but whose callee already has a js:fragment
  filter not exists {
    $this js:callee ?expression.
    filter not exists { ?expression js:fragment []. }
  }
  
  # ...but whose argument array already has a js:fragment for each argument in the array
  filter not exists {
    $this js:arguments ?arrayOfArguments.
    ?arrayOfArguments rdf:first+ ?argument.
    filter not exists {?argument js:fragment []. }
  }  
}''';
    rdfs:isDefinedBy js:.

rule:CallExpression
    a sh:SPARQLRule;
    rdfs:comment ''@en;
    skos:prefLabel ''@en;
    sh:prefixes js:;
    sh:construct '''
construct {

  # Assert the new javascript fragment for this javascript node
  $this js:fragment ?fragment.
  
} where {
  
  $this js:callee ?callee.
  ?callee js:fragment ?calleeFragment.
  
  OPTIONAL{
   {select (group_concat(?argumentFragment; separator=",") as ?argumentsFragment)
     where {
     $this js:arguments ?arrayOfArguments.
     ?arrayOfArguments rdf:first+ ?argument.
     ?argument js:fragment ?argumentFragment.
   }}
  }
  
  bind(concat(?calleeFragment, "(", coalesce(?argumentsFragment,""), ")") as ?fragment)
  
}''';
    rdfs:isDefinedBy js:.

shp:NewExpression
    a sh:NodeShape;
    sh:rule rule:NewExpression;
    sh:target target:NewExpression;
    skos:prefLabel 'NewExpression shape'@en;
    rdfs:isDefinedBy js:.

target:NewExpression
    a sh:SPARQLTarget;
    rdfs:comment ''@en;
    sh:prefixes js:;
    sh:select '''
select $this {

  # Select all conditional expressions in the javascript AST...
  $this a/rdfs:subClassOf* js:NewExpression.
  
  # ...that do not yet have a javascript fragment.
  filter not exists { $this js:fragment []. }

  # ...but whose callee expression already has a js:fragment
  filter not exists {
    $this js:callee ?callee.
    ?callee rdf:type/rdfs:subClassOf* js:Expression.    
    filter not exists { ?callee js:fragment []. }
  }

  # ...and whose arguments expression already has a js:fragment
  filter not exists {
    $this js:arguments ?array.
    ?array rdf:first+ ?argument.
    ?argument rdf:type/rdfs:subClassOf* js:Expression.
    filter not exists { ?argument js:fragment []. }
  }
}''';
    rdfs:isDefinedBy js:.

rule:NewExpression
    a sh:SPARQLRule;
    rdfs:comment ''@en;
    skos:prefLabel ''@en;
    sh:prefixes js:;
    sh:construct '''
construct {

  # Assert the new javascript fragment for this javascript node
  $this js:fragment ?fragment.
  
} where {

  $this js:callee ?callee.
  ?callee rdf:type/rdfs:subClassOf* js:Expression;
          js:fragment ?calleeFragment.

  {select (group_concat(?argumentFragment; separator=",") as ?argumentsFragment)
     where {
     $this js:arguments ?arrayOfArguments.
     ?arrayOfArguments rdf:first+ ?argument.
     ?argument js:fragment ?argumentFragment.
    }
   }

  bind(concat("new ", ?calleeFragment, ' (', ?argumentsFragment, ')') as ?fragment)
}
''';
    rdfs:isDefinedBy js:.

shp:SequenceExpression
    a sh:NodeShape;
    sh:rule rule:SequenceExpression;
    sh:target target:SequenceExpression;
    skos:prefLabel 'SequenceExpression shape'@en;
    rdfs:isDefinedBy js:.

target:SequenceExpression
    a sh:SPARQLTarget;
    rdfs:comment ''@en;
    sh:prefixes js:;
    sh:select '''
select $this {

  # Select all conditional expressions in the javascript AST...
  $this a/rdfs:subClassOf* js:SequenceExpression.
  
  # ...that do not yet have a javascript fragment.
  filter not exists { $this js:fragment []. }

  # ...and whose expressions already have a js:fragment
  filter not exists {
    $this js:expressions ?array.
    ?array rdf:first+ ?expression.
    ?expression rdf:type/rdfs:subClassOf* js:Expression.
    filter not exists { ?expression js:fragment []. }
  }
}''';
    rdfs:isDefinedBy js:.

rule:SequenceExpression
    a sh:SPARQLRule;
    rdfs:comment ''@en;
    skos:prefLabel ''@en;
    sh:prefixes js:;
    sh:construct '''
construct {

  # Assert the new javascript fragment for this javascript node
  $this js:fragment ?fragment.
  
} where {

  {select (group_concat(?expressionFragment; separator=",") as ?expressionsFragment)
     where {
     $this js:expressions ?arrayOfExpressions.
     ?arrayOfExpressions rdf:first+ ?expression.
     ?expression rdf:type/rdfs:subClassOf* js:Expression.     
     ?expression js:fragment ?expressionFragment.
    }
   }

  bind(concat('(', ?expressionsFragment, ')') as ?fragment)
}
''';
    rdfs:isDefinedBy js:.
    


